/*
	SuperLED WiFi Bridge (Spark Core)
	This program has a simple mission: transfer anything sent to it over WiFi to Arduino connected to the LED via SPI and reverse.
	This Arduino is WiFi server and SPI master (TWBR: 12 == 400 KHz)
	
	NOTE: We use Spark.publish("Debug",debugString) to send debug information in semi-real time 

	
	IMPORTANT NOTE TO SELF: When using the 5V regulated PSU, connect to Arduino 5V pin and NOT vin!
*/

#define COLOR_BYTES 3					// 3 bytes required per led for full color
#define BUFFER_SIZE 768					// NUM_LED * COLOR_BYTES - we need speed so we remove the need for arithmetic in loops
#define WLAN_SSID	"ShadowNETz"
#define WLAN_PASS	"LoveSHADOWNET"
//#define BAUD_RATE0 115200               // Debug serial baud rate
#define BAUD_RATE1 230400               // Data serial baud rate (400000 beore, but 230400 should be sweet spot)
#define LISTEN_PORT 2208				// What TCP port to listen on for connections.

uint8_t screenBuffer[BUFFER_SIZE];      // The byte buffer - one full screen
uint8_t command;                        // The command we get from the python client
char myIpString[24];                    // IP-adresse of Spark Core
int freeRAM;                            // Available RAM


TCPServer LEDserver = TCPServer(LISTEN_PORT);
TCPClient client;

char reportString[40];
int connected;                          // boolean, but spark functions only take int
    
static const uint8_t sparkLogo[] = {    // static const will put the whole thing in flash memory
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x13, 0x19, 0x01, 0x12, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x5A, 0x02, 0x41, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x2B, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x6C, 0x93, 0x01, 0x6A, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x2B, 0x39, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB6, 0xFA, 0x02, 0x23, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xA0, 0xDB, 0x01, 0x9F, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x24, 0x30, 0x03, 0xB6, 0xF9, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x23, 0x2F, 0x00, 0xDC, 0xFF, 0x03, 0x78, 0xA4, 0x00, 0x00, 0x00, 0x03, 0x62, 0x86, 0x02, 0x61, 0x84, 0x00, 0x00, 0x00, 0x03, 0x79, 0xA5, 0x00, 0xDC, 0xFF, 0x03, 0x22, 0x2D, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x78, 0xA3, 0x00, 0xC1, 0xFF, 0x01, 0xB9, 0xFE, 0x02, 0x1C, 0x26, 0x02, 0x1D, 0x27, 0x01, 0xBA, 0xFE, 0x00, 0xC1, 0xFF, 0x03, 0x76, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xB9, 0xFE, 0x00, 0xB1, 0xF4, 0x00, 0xBC, 0xFF, 0x00, 0xBC, 0xFF, 0x00, 0xB1, 0xF4, 0x01, 0xB9, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x02, 0x13, 0x19, 0x02, 0x42, 0x5A, 0x02, 0x6C, 0x93, 0x01, 0xA0, 0xDB, 0x03, 0x62, 0x86, 0x02, 0x1C, 0x25, 0x00, 0xBC, 0xFF, 0x00, 0xAE, 0xEF, 0x00, 0xAE, 0xEF, 0x00, 0xBC, 0xFF, 0x02, 0x1B, 0x24, 0x03, 0x64, 0x88, 0x01, 0x9F, 0xDB, 0x02, 0x6C, 0x93, 
0x02, 0x41, 0x59, 0x01, 0x13, 0x19,
0x02, 0x12, 0x18, 0x02, 0x41, 0x58, 0x01, 0x6A, 0x92, 0x02, 0x9F, 0xD9, 0x02, 0x61, 0x84, 0x02, 0x1D, 0x27, 0x00, 0xBC, 0xFF, 0x00, 0xAE, 0xEF, 0x00, 0xAE, 0xEF, 0x00, 0xBC, 0xFF, 0x02, 0x1C, 0x25, 0x03, 0x62, 0x86, 0x02, 0x9E, 0xD9, 0x01, 0x6A, 0x91, 
0x02, 0x40, 0x58, 0x02, 0x12, 0x17,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xBA, 0xFE, 0x00, 0xB1, 0xF4, 0x00, 0xBC, 0xFF, 0x00, 0xBC, 0xFF, 0x00, 0xB1, 0xF4, 0x01, 0xB9, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x79, 0xA5, 0x00, 0xC1, 0xFF, 0x01, 0xB9, 0xFD, 0x02, 0x1B, 0x24, 0x02, 0x1C, 0x25, 0x01, 0xB9, 0xFE, 0x00, 0xC1, 0xFF, 0x03, 0x77, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x24, 0x30, 0x00, 0xDC, 0xFF, 0x03, 0x77, 0xA2, 0x00, 0x00, 0x00, 0x02, 0x64, 0x88, 0x02, 0x62, 0x86, 0x00, 0x00, 0x00, 0x03, 0x77, 0xA3, 0x00, 0xDC, 0xFF, 0x02, 0x22, 0x2E, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB7, 0xF9, 0x02, 0x21, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x9F, 0xDA, 0x01, 0x9E, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x2E, 0x03, 0xB6, 0xF9, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x2B, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x6C, 0x93, 0x01, 0x6A, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x2B, 0x39, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x41, 0x59, 0x02, 0x40, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x13, 0x19, 0x01, 0x11, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// The following is used for the freeMemory() function

unsigned int __heap_start;
void *__brkval;

struct __freelist {
    size_t sz;
    struct __freelist *nx;
};

struct __freelist *__flp;   // The head of the free list structure


// Function declarations
int freeMemory();
int freeListSize();
void pubDebug();
    
    
void setup() {
    delay(1000);                // make sure we can re-flash the core (delays of 1000 or more as well as at the end of the loop() is 
                                // where the Spark Core checks the cloud for updates)
                                
    pubDebug("Starting");       // publishing debug information to cloud, can be read via subscription
    connected = 0;
    Spark.variable("connected", &connected, INT);    // not yet connected to Arduino
    
    pinMode(7, OUTPUT);         // onboard led
    digitalWrite(7, LOW);
    
    // Sends the IP address of the Spar Core to the cloud. Can be retrieved manually with :
	// curl "https://api.spark.io/v1/devices/48ff74065067555037201287/ipAddress?access_token=fbc3cd7865c567b740b60543b6adb348d7f76c1f"
    IPAddress myIp = Network.localIP();
    sprintf(reportString, "%d.%d.%d.%d", myIp[0], myIp[1], myIp[2], myIp[3]);
    Spark.variable("ipAddress", reportString, STRING);
    
    sprintf(reportString, "IP address: %d.%d.%d.%d", myIp[0], myIp[1], myIp[2], myIp[3]);
    pubDebug(reportString);       // publishing debug information to cloud, can be read via subscription
    
    freeRAM = freeMemory();
    Spark.variable("freeRAM", &freeRAM, INT);   // Reporting RAM free to cloud. Can be retrieved manually with :
    
    sprintf(reportString, "Free RAM: %d", freeRAM);
    pubDebug(reportString);       // publishing debug information to cloud, can be read via subscription
    
    // curl "https://api.spark.io/v1/devices/48ff74065067555037201287/freeRAM?access_token=fbc3cd7865c567b740b60543b6adb348d7f76c1f"

	//Serial.begin(BAUD_RATE0);		// Initializing serial communication
	//    while(!Serial.available()) {delay(100);} // Wait here until the user presses something in the Serial Terminal, for debugging

	//Serial.println("- WIFI SPARK CORE LED MASTER LIVE AGAIN!");
	digitalWrite(7, HIGH);
	Serial1.begin(BAUD_RATE1);		// 
    //Serial.println("--> Started serial communications, establishning connection to LEDslave");
    while(true) {   // We keep bombarding LEDslave with keepalives until we get an ack -> ready to go
                    // Worst case, the Arduino is still reading a buffer, so we might have to do this 768-1 times theoretically
                    // to fill the buffer with zeros, and then catch the ARduino's attention as it starts looking for a new command
        Serial1.write(0);   // sending 0 (not "0" but binary zero) to indicate command incoming
        digitalWrite(7, HIGH);
        delay(100);
        digitalWrite(7, LOW);
        //delay(10);
        Serial1.write('K'); // sending keepalive to get ack from LEDslave (ASCII 75 = 'K')
        delay(1000);        // we wait a second between each one
        //delay(10);
        if(Serial1.read() == 'A') break;
    }
    digitalWrite(7, HIGH);
    connected = 1;
    Spark.variable("connected", &connected, INT);    // connected to Arduino
    
    //Serial.println("--> LEDslave acknowledges - serial data connection ready - sending logo");
    Serial1.write('G');
    while (true) if(Serial1.read() == 'A') break;
    Serial1.write(&sparkLogo[0], BUFFER_SIZE / 2);
    Serial1.write(&sparkLogo[BUFFER_SIZE / 2], BUFFER_SIZE / 2);
    // TODO: See if we really need to split it in two

	LEDserver.begin();	// Starting the server
	Serial.print("--> Server ready at ");
	Serial.print(Network.localIP());
	Serial.print(" port: ");
	Serial.println(LISTEN_PORT);
	digitalWrite(7, LOW);
    //RGB.color(255, 255, 255);   // white before we got clients
}




// Main loop, where we get our values form serial and display it
void loop() {


    client = LEDserver.available();
    
	if(client) {
	    digitalWrite(7, HIGH);
	    pubDebug("Got client");
	    //RGB.color(204, 0, 102);   // solid purple when when we have a clientbut have not yet received screen update data
		Serial.println("--> We have a new client");
		client.write('S'); 	// Sending single byte ('S') to indicate start of communications
	}
	while (client) {
		if (client.available() > 0) {
			uint8_t command = client.read();	// reads single byte from client

			// Here we deal with commands that require more data to follow
			if (command == 'G') {
			    RGB.color(204, 0, 102);                     // solid green when we start getting screen update data
			    Serial1.write(0);                           // letting the Arduino know a command is coming
			    Serial1.write(command);	                   	// we pass on the one byte command to Arduino
			    while (Serial1.read() != 'A');              // wait for ack

				// slow version, to make sure we don't have buffer overruns
				for (int i=0; i < BUFFER_SIZE; i++) {
				    screenBuffer[i] = client.read();
				}
				
				Serial1.write(&screenBuffer[0], BUFFER_SIZE / 2);
                Serial1.write(&screenBuffer[BUFFER_SIZE / 2], BUFFER_SIZE / 2);
				while (Serial1.read() != 'D');
				    client.write('D');      // we let the client know we're done
				Serial.println("--> Full buffer received and sent");
				
			} else if (command == 'B') {
			    Serial1.write(0);                           // letting the Arduino know a command is coming
			    Serial1.write(command);	                   	// we pass on the one byte command to Arduino
			    
			    while (Serial1.read() != 'A');              // wait for ack
				while(!client.available()) {};	// we wait for the brightness value NOTE: do we need this?
				Serial1.write(client.read());		// we send brightness value directly to Arduino_Serial
				Serial.println("--> New brightness value received and sent");
				while (Serial1.read() != 'D');
				    client.write('D');      // we let the client know we're done
				
			} else if (command == 'T') {
			    Serial1.write(0);                           // letting the Arduino know a command is coming
			    Serial1.write(command);	                   	// we pass on the one byte command to Arduino
			    
			    while (Serial1.read() != 'A');              // wait for ack
				Serial.println("--> HW test received and sent");
				while (Serial1.read() != 'D');
				    client.write('D');      // we let the client know we're done
				    
			} else if (command == 'K') {    // Keep-alive from Python client. We respond to show we're alive.
				    client.write('D'); 
				
			} else if (command == 'Q') {
			    client.write('A');                          // we let the client know we're shutting down
			    delay(1000);                                // waiting a second to let the client get our ack
				client.stop();                              // Disconnecting the network client
				RGB.color(255, 255, 255);                   // solid white when we have no clients
				Serial1.write(0);                           // letting the Arduino know a command is coming
			    Serial1.write('Z');	                   	    // we zero the display when network client disconnects
			    while (Serial1.read() != 'A');              // wait for ack
				Serial.println("--> Display zeroed");
				while (Serial1.read() != 'D');              // await for "done" from Arduino
				digitalWrite(7, LOW);
			}
		}
	} 
}



void pubDebug(char *msg) {
    /*char publishString[40];
    unsigned long now = millis();
    unsigned nowSec = now/1000UL;
    unsigned sec = nowSec%60;
    unsigned min = (nowSec%3600)/60;
    unsigned hours = (nowSec%86400)/3600;
    sprintf(publishString,"%u:%u:%u -> %s",hours,min,sec,msg);
    Spark.publish("Debug",publishString);*/
    Spark.publish("SuperLED", "Yeah", 60, PRIVATE);
    return;
}


/* Calculates the size of the free list */
int freeListSize() {
    struct __freelist* current;
    int total = 0;

    for (current = __flp; current; current = current->nx) {
        total += 2; /* Add two bytes for the memory block's header  */
        total += (int) current->sz;
    }

    return total;
}

int freeMemory() {
    int free_memory;

    if ((int)__brkval == 0) {
        free_memory = ((int)&free_memory) - ((int)&__heap_start);
    } else {
        free_memory = ((int)&free_memory) - ((int)__brkval);
        free_memory += freeListSize();
    }
    return free_memory;
}

