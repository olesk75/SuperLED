

	# WATCH OUT
	# WE FIRST MUST DECIDE WHICH PART OF THE BINARY BUFFER WE WANT TO PUT ON SCREEN
	# TODO: Get everything in order


	char_counter = 0

	element_counter = 0
	counter = 0
	debug_counter = 0
	#rgb_buffer = b'' # Resetting the rgb_buffer
	rgb_buffer = bytearray()
	for char_counter in range(len(binary_buffer)):
		x = binary_buffer[char_counter]
		print('binary_buffer position:', element_counter)
		element_counter += 1

		# Each value of x is a binary number (00000000 to 11111111 (256))
		# We need to to substitute each bit with a byte triple, startng at the most significant bit (to the left)
		for bit_counter in range(8):

			bit_value = x >> (7 - bit_counter)    # We shift the bits to the right, leaving the one we want rightmost
			bit_value &= 0b00000001             # We set all other 7 bits to the left to zero with a bitmask

			print("bit_value", bit_value)

			if bit_value == 0:
				rgb_buffer.append(0x00)
				rgb_buffer.append(0x00)
				rgb_buffer.append(0x00)
			if bit_value == 1:
				rgb_buffer.append(red)
				rgb_buffer.append(green)
				rgb_buffer.append(blue)

		print("rgb_buffer size: ", len(rgb_buffer))
		#print("rgb_buffer size: ", len(rgb_buffer))
		counter += 1

	# We now have the full RGB buffer. We now need to know how much to offset it if we want to scroll it
	# rgb_buffer is ok
	print()
	print('rgb_buffer length: ', len(rgb_buffer), ' (or', len(rgb_buffer) / (16 * 3), 'columns wide)')
	print('rgb_buffer_line_length: ', len(rgb_buffer) / 16 / 3)
	print('Number of characters in rgb_buffer=', len(rgb_buffer) / 16 / 3 / 16)

	print('')
	print (rgb_buffer)

	text_offset = 1
	rgb_buffer_line_length = (len(rgb_buffer) / 3 / 16 )    # Number of horisontal leds in buffer

	for line in range(0, 16):
		start_pos = 1

		start_pos = (line * 16 * 3) + (text_offset * 3)
		end_pos = (line * 16 * 3) + (16 * 3) + (text_offset * 3)
		screen_buffer += rgb_buffer[start_pos:end_pos]

	print('screen_buffer length:', len(screen_buffer))


	if not OFFLINE: ser.write(screen_buffer)

	if True: return     # Better than simply "return", as IDE then orphans everything below

	# TODO: Scrolling
	while text_offset < rgb_buffer_line_length:
		screen_buffer = b''     # Flush the screen buffer
		for line in range(0, 16):
			start_pos = (line * rgb_buffer_line_length) + text_offset
			end_pos = (1 + line) * rgb_buffer_line_length - 1 + text_offset
			screen_buffer += rgb_buffer[start_pos:end_pos]

			print("rgb_buffer_line_length: ", rgb_buffer_line_length)
			print("Text_offset:", text_offset)
			print("Start: ", start_pos)
			print("End: ", end_pos)
			print("Range: ", end_pos - start_pos)

			print('screen_buffer type: ', len(screen_buffer))
		# We got one full run
		text_offset += 1
		time.sleep(1/speed)
		if not OFFLINE: ser.write(screen_buffer)

		# response = ser.read(3)
		# if response != '':
		# 	if int(response) == (NUM_LEDS * 3):
		# 		print("- Full screen update acknowledged")

	#sys.exit("Done for now")